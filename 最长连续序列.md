```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> MapNum(nums.cbegin(), nums.cend()); // set链接
        int maxL = 0;                                        // 最长长度
        for (int& num : nums) {
            int count = 1;
            int n = num - 1;
            while (MapNum.count(n)==1) { // 前一个数存在
                ++count;
                --n; // 代表当前向前长度
            }
            maxL = max(maxL, count);
        }   //计算重复链条
        return maxL;
    }
};
```

```
思路：用set存储，让数组中的数形成链条。遍历数，找寻前一个数是否存在，存在则此链条长度加1，最后与最大的比较。能通过9成，最后1成超时。问题出现在，每次遍历一个数，需要重新计算链条长度，存在大量重复计算。改进思路，利用回溯记忆，相同的长度只计算一次，避免重复计算。首先发现可以设置flag，遍历过了就设置false避免重复计算。再一步思考，可以用unordered_map来存储这样的键值对，最后发现完全可以用u_set，计算过后直接移除，更加省事。
```

