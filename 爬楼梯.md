```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n < 3) {
            return n;
        }
        return climbStairs(n - 1) + climbStairs(n - 2);
    }
};
```

```
思路：此题初看觉得费解，但可以先推理前几项。到达1阶的方法记为F1，1种。到达2阶记为F2，有2种。达到3阶可以由F1爬2阶，或F2爬1阶。由此可以延伸对于N阶，可以由Fn-1+Fn-2组成，得到关系式FN=FN-1+FN-2。利用递归的特性，一层一层往下递归，直到边界N=3时，然后再一层层返回。经过验证，可以通过但超时。原因是递归开销较大，且存在大量重复运算，随着n越大，则效率越低。可以想到的改进思路是，记录中间重复计算的值，下次再次需要直接返回而不再次计算。或者将递归用循环展开，这里采用循环展开易于改造实现。
```

```c++
class Solution {
public:
    int climbStairs(int n) {
        if (n < 3) {
            return n;
        }
        int f1 = 1, f2 = 2, f3;
        for (int i = 0; i < n - 2; ++i) {
            f3 = f1 + f2;
            f1 = f2;
            f2 = f3;
        }
        return f3;
    }
};
```

```
思路：循环展开的思路来自于归纳。此处用fn代表到达n阶方法数。有f1(+2)+f2(+1)=f3 ,f2(+2)+f3(+1)=f4 ,由此只要知道前两项就能知道n的结果数，并且我们可以用滑步的想象，将变量滑动使用，减少了额外的空间开销。
```

